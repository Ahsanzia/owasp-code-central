using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Xml.Serialization;
using TigerClient.Document.Condition;

namespace TigerClient.Document
{
    public class AutomatedTest: DocumentPart
    {
        private System.Net.WebRequest request = null;

        private string name;
        private string description;
        private MethodType method;
        private string relativePath;
        private TestStatusType status;
        private string statusMessage;

        private int responseStatusCode;
        private string responseBody;
        //private Alert alert = new Alert();

        private DocumentPartCollection<TestParameter> parameters = new DocumentPartCollection<TestParameter>();
        private DocumentPartCollection<Alert> alerts = new DocumentPartCollection<Alert>();

        public AutomatedTest()
        {
            parameters.Modified += new EventHandler<DocumentPartModifiedEventArgs>(OnParametersModified);
            alerts.Modified += new EventHandler<DocumentPartModifiedEventArgs>(OnAlertsModified);
        }

        [Browsable(false)]
        public int ResponseStatusCode
        {
            get { return responseStatusCode; }
        }

        [Browsable(false)]
        public string ResponseBody
        {
            get { return responseBody; }
        }

        [XmlIgnore(), Category("Status")]
        public TestStatusType Status
        {
            get
            {
                return status;
            }
            internal set
            {
                status = value;
                // this is a transient property, so I commented out the following line
                //OnModified(new DocumentPartModifiedEventArgs(this, "Status", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        [XmlIgnore(), Category("Status")]
        public string StatusMessage
        {
            get { return statusMessage; }
            internal set
            {
                statusMessage = value;
                // this is a transient property, so I commented out the following line
                //OnModified(new DocumentPartModifiedEventArgs(this, "StatusMessage", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        [XmlArrayItem("Parameter")]
        [Description("Parameters to pass to the test"), Category("Configuration")]
        public DocumentPartCollection<TestParameter> Parameters
        {
            get { return parameters; }
            set { parameters = value; }
        }

        [Description("Alerts generated by this test"), Category("Alerts")]
        public DocumentPartCollection<Alert> Alerts
        {
            get { return alerts; }
            set { alerts = value; }
        }

        [Description("Method used to access the test"), Category("Configuration")]
        public MethodType Method
        {
            get { return method; }
            set
            {
                method = value;
                OnModified(new DocumentPartModifiedEventArgs(this, "Method", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        [DisplayName("Relative Path"), Description("This test's path relative to target's path"), Category("Configuration")]
        public string RelativePath
        {
            get { return relativePath; }
            set
            {
                relativePath = value;
                OnModified(new DocumentPartModifiedEventArgs(this, "RelativePath", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        [Description("User-friendly name of this test."), Category("General")]
        public string Name
        {
            get { return name; }
            set
            {
                name = value;
                OnModified(new DocumentPartModifiedEventArgs(this, "Name", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        [Description("Description of this test."), Category("General")]
        public string Description
        {
            get { return description; }
            set
            {
                description = value;
                OnModified(new DocumentPartModifiedEventArgs(this, "Description", DocumentPartModificationType.DocumentPartPropertyModified));
            }
        }

        public override string DisplayName
        {
            get
            {
                if (!string.IsNullOrEmpty(name)) return name;
                return "<Untitled Test>";
            }
        }

        public override string ErrorMessage
        {
            get
            {
                //if (string.IsNullOrEmpty(relativePath))
                //    return "Relative path must be provided.";
                //else
                //{
                    foreach (TestParameter tp in Parameters)
                        if (!tp.IsValid) return "Some parameters for this test are not valid.";

                    foreach (Alert a in Alerts)
                        if (!a.IsValid) return "Some alerts for this test are not valid.";
                //}

                return null;
            }
        }

        private void OnParametersModified(object sender, DocumentPartModifiedEventArgs e)
        {
            if (e.AffectedDocumentPart != null)
                if (e.AffectedDocumentPart.Parent == null)
                    e.AffectedDocumentPart.Parent = this;

            DocumentPartModifiedEventArgs eventArgs;

            if (e.ModificationType == DocumentPartModificationType.ChildDocumentPartsCleared)
                eventArgs = new DocumentPartModifiedEventArgs(this, "Parameters", DocumentPartModificationType.ChildDocumentPartsCleared);
            else
                eventArgs = e;

            OnModified(eventArgs);
        }

        private void OnAlertsModified(object sender, DocumentPartModifiedEventArgs e)
        {
            if (e.AffectedDocumentPart != null)
                if (e.AffectedDocumentPart.Parent == null)
                    e.AffectedDocumentPart.Parent = this;

            DocumentPartModifiedEventArgs eventArgs;

            if (e.ModificationType == DocumentPartModificationType.ChildDocumentPartsCleared)
                eventArgs = new DocumentPartModifiedEventArgs(this, "Alerts", DocumentPartModificationType.ChildDocumentPartsCleared);
            else
                eventArgs = e;

            OnModified(eventArgs);
        }

        public void Run()
        {
            Run(false);
        }

        public void Run(bool testRun)
        {
            if (!(IsValid && ((parent as Document.Target).IsValid))) throw new InvalidOperationException("Only valid tests on valid targets can be run.");

            Target target = parent as Target;
            if (target == null) throw new ApplicationException("Internal Error: unable to access target for this test.");

            if (relativePath == null) relativePath = "";

            string targetPath = target.Path.TrimEnd('/');
            string fullPath = targetPath + "/" + relativePath.TrimStart('/');

            string paramString = "";
            foreach (TestParameter p in parameters)
            {
                if (paramString != "") paramString += "&";

                paramString += System.Web.HttpUtility.UrlEncode(p.Name);
                if (!string.IsNullOrEmpty(p.Value))
                    paramString += "=" + System.Web.HttpUtility.UrlEncode(p.Value);
            }

            request = null;
            System.Net.HttpWebResponse response = null;

            int responseStatusCode = int.MinValue;
            string responseBody = null;

            try
            {
                if (!testRun)
                {
                    Status = TestStatusType.Executing;
                    StatusMessage = "Test is now executing.";
                }

                switch (method)
                {
                    case MethodType.GET:
                        if (paramString != "") fullPath += "?" + paramString;
                        request = System.Net.WebRequest.Create(fullPath);
                        request.Method = "GET";
                        break;
                    case MethodType.POST:
                        request = System.Net.WebRequest.Create(fullPath);
                        request.ContentType = "application/x-www-form-urlencoded";
                        request.Method = "POST";
                        byte[] paramBytes = System.Text.Encoding.ASCII.GetBytes(paramString);
                        request.ContentLength = paramBytes.Length;
                        request.GetRequestStream().Write(paramBytes, 0, paramBytes.Length);
                        break;
                }

                response = (System.Net.HttpWebResponse) request.GetResponse();
                responseStatusCode = (int)response.StatusCode;
                
                System.IO.StreamReader sr = new System.IO.StreamReader(response.GetResponseStream());
                responseBody = sr.ReadToEnd();

                if (!testRun)
                {
                    Status = TestStatusType.Succeeded;
                    StatusMessage = "Test executed successfully.";
                }
            }
            catch (System.Net.WebException wex)
            {
                if (wex.Response != null)
                {
                    System.Net.HttpWebResponse wr = (System.Net.HttpWebResponse)wex.Response;
                    responseStatusCode = (int)wr.StatusCode;
                }

                if (!testRun)
                {
                    if (wex.Status == System.Net.WebExceptionStatus.RequestCanceled)
                    {
                        Status = TestStatusType.Cancelled;
                        StatusMessage = "User cancelled.";
                    }
                    else
                    {
                        Status = TestStatusType.Failed;
                        StatusMessage = wex.Message;
                    }
                }

                if (testRun)
                    throw;
            }
            catch (Exception ex)
            {
                if (!testRun)
                {
                    Status = TestStatusType.Failed;
                    StatusMessage = ex.Message;
                }

                if (testRun)
                    throw;
            }
            finally
            {
                this.responseStatusCode = responseStatusCode;
                this.responseBody = responseBody;

                foreach (Document.Alert alert in alerts)
                {
                    ICondition condition = alert.Condition as ICondition;
                    condition.SetResponseBody(responseBody);
                    condition.SetResponseStatusCode(responseStatusCode);
                }
            }
        }

        public void Stop()
        {
            if (request != null)
                request.Abort();
        }
    }
}
